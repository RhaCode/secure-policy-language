# SPL System Notes - Simplified Implementation Guide

## Core Architecture

**SPL is a policy compiler that transforms human-readable access control rules into executable JSON, with AI-powered security analysis.**

```
User Code → Lexer → Parser → Semantic Analysis → AI Scan → JSON → Database → Engine → Decisions
```

---

## 1. Language Design

### Syntax Structure
```spl
USER alice { role: Admin, department: IT }
RESOURCE DB_Finance { path: /data/financial, type: database }
ALLOW action: read, write ON RESOURCE: DB_Finance IF (user.role == "Admin" AND time.hour >= 9)
DENY action: delete ON RESOURCE: DB_Finance IF (user.department == "Sales")
```

### Key Characteristics
- **Declarative**: WHO (user), WHAT (action), WHICH (resource), WHEN (conditions)
- **Boolean Logic**: AND, OR, NOT with precedence (NOT > AND > OR)
- **Default-Deny**: DENY overrides ALLOW
- **Attribute-Based**: Policies based on user.role, time.hour, resource.type, etc.

---

## 2. Compilation Pipeline (4 Stages)

### Stage 1: Lexer (Text → Tokens)
**Input**: `"USER alice { role: Admin }"`  
**Output**: `[TOKEN_USER, TOKEN_ID("alice"), TOKEN_LBRACE, TOKEN_ID("role"), TOKEN_COLON, TOKEN_ID("Admin"), TOKEN_RBRACE]`  
**Error Handling**: Invalid characters, line tracking

### Stage 2: Parser (Tokens → AST)
**Input**: Token stream  
**Output**: Abstract Syntax Tree
```
ProgramNode
├── UserNode(name="alice", properties={role: "Admin"})
├── ResourceNode(name="DB_Finance", properties={...})
└── PolicyNode(type="ALLOW", actions=["read", "write"], resource="DB_Finance", condition=...)
```
**Error Handling**: Syntax errors with line numbers, missing braces

### Stage 3: Semantic Analysis (AST → Validated AST)
**Checks**:
- Reference validation (does USER/RESOURCE exist?)
- Type checking (is user.role a string?)
- Conflict detection (contradictory policies)
- Privilege escalation risks (Developer accessing Finance DB)

**Output**:
```json
{
  "success": true,
  "errors": [],
  "warnings": [{"line": 25, "type": "OVERLY_PERMISSIVE", "severity": "MEDIUM"}],
  "conflicts": [{"line1": 24, "line2": 28, "type": "CONTRADICTORY_CONDITIONS"}]
}
```

### Stage 4: Code Generation (AST → JSON)
**Output**: Compiled policy JSON
```json
{
  "users": [{"name": "alice", "properties": {"role": "Admin"}}],
  "resources": [{"name": "DB_Finance", "properties": {...}}],
  "policies": [{
    "type": "ALLOW",
    "actions": ["read", "write"],
    "resource": "DB_Finance",
    "condition": "user.role == \"Admin\" AND time.hour >= 9"
  }],
  "metadata": {"version": "1.0", "compile_time": "2024-11-23T10:30:00Z"}
}
```

---

## 3. AI Security Analysis (LLM Integration)

**When**: After semantic analysis detects conflicts/warnings  
**Process**: Send compiled policy + conflicts to GPT-4/Claude/Gemini

**Prompt Template**:
```
Analyze these access control policies for security risks:
POLICIES: [compiled_json]
CHECKS: overly permissive rules, contradictions, privilege escalation, unusual patterns
Return JSON: [{"type": "PRIVILEGE_ESCALATION", "severity": "HIGH", "line": 42, "risk": "...", "recommendation": "..."}]
```

**Output**: Risk findings with line numbers, severity, and recommendations

---

## 4. Database Storage (3 Tiers)

### Tier 1: Dynamic Data (Users & Resources)
```sql
CREATE TABLE users (id, username, role, email, department, created_at, active);
CREATE TABLE resources (id, name, type, path, description, owner, created_at);
```
**Usage**: Updated by CRUD operations, fetched during access checks

### Tier 2: Compiled Policies (Static)
```sql
CREATE TABLE compiled_policies (id, name, source_code, compiled_json, version, active, created_at);
```
**Usage**: Generated by compiler, loaded once into memory, not modified at runtime

### Tier 3: Audit Logs (Append-Only)
```sql
CREATE TABLE audit_logs (id, timestamp, username, action, resource, allowed, reason, ip_address);
```
**Usage**: Every access decision logged for compliance

---

## 5. Policy Execution (Runtime)

### Access Request Flow
```
POST /api/execution/check-access
{
  "username": "alice",
  "action": "read",
  "resource": "DB_Finance",
  "context": {"hour": 14}
}
```

### Engine Evaluation Process
1. **Fetch user from DB**: `{name: "alice", role: "Admin"}`
2. **Fetch resource from DB**: `{name: "DB_Finance", type: "database"}`
3. **Build context**: `{user: {role: "Admin"}, time: {hour: 14}}`
4. **Iterate policies** (from memory):
   - Match resource name
   - Match action
   - Evaluate condition: `user.role == "Admin" AND time.hour >= 9` → `True`
5. **Decision logic**:
   - If DENY matches → DENIED
   - Else if ALLOW matches → ALLOWED
   - Else → DENIED (default deny)
6. **Log to audit_logs**
7. **Return response**

### Response
```json
{
  "allowed": true,
  "reason": "ALLOW policy matched",
  "matched_policies": [{...}],
  "context": {"user": {"role": "Admin"}, "time": {"hour": 14}}
}
```

---

## 6. API Routes

### Compilation
**POST /api/compile**  
Input: `{"code": "USER alice {...}"}`  
Output: `{"success": true, "policy_id": 42, "conflicts": [...]}`

### Execution
**POST /api/execution/check-access**  
Input: `{"username": "alice", "action": "read", "resource": "DB_Finance"}`  
Output: `{"allowed": true, "reason": "...", "matched_policies": [...]}`

### Security Analysis
**GET /api/security-analysis?policy_id=42**  
Output: `{"findings": [{"type": "PRIVILEGE_ESCALATION", "severity": "HIGH", ...}]}`

---

## 7. Key Implementation Principles

### Separation of Concerns
- **Lexer**: Only tokenization
- **Parser**: Only syntax validation
- **Semantic Analyzer**: Only validation + conflict detection
- **Policy Engine**: Only runtime evaluation

### Data Flow
- **Compile once** (expensive): Text → AST → JSON → Database
- **Execute many times** (fast): Context + Memory policies → Decision
- **Policies in memory**: O(n) evaluation where n = policy count

### Error Handling
- Every stage reports line numbers
- Errors propagate with context
- Frontend displays rich error messages

### Security
- **Default-deny**: No policy = access denied
- **DENY wins**: DENY policies override ALLOW
- **No dynamic code execution**: Only eval() with sanitized conditions
- **Audit trail**: Every decision logged

---

## 8. Complete Workflow Summary

**Compilation Workflow**:
```
1. User writes SPL → POST /api/compile
2. Lexer tokenizes → Token stream
3. Parser builds AST → Tree structure
4. Semantic Analyzer validates → Errors/warnings/conflicts
5. LLM scans (optional) → AI risk findings
6. Code Generator produces JSON → Compiled policy
7. Database saves → compiled_policies table
8. Policy Engine loads → In-memory for fast access
```

**Execution Workflow**:
```
1. User requests access → POST /api/execution/check-access
2. Fetch user from DB → {role: "Admin"}
3. Fetch resource from DB → {type: "database"}
4. Build context → {user, time, resource}
5. Engine evaluates policies (memory) → Decision
6. Log to audit_logs → Compliance trail
7. Return response → {allowed: true/false, reason: "..."}
```

---

## 9. Critical Implementation Notes

- **No localStorage in artifacts**: Use React state or in-memory variables
- **PEMDAS/operator precedence**: NOT > AND > OR, use parentheses for grouping
- **Policy inheritance**: Roles define base permissions, policies refine them
- **Least privilege**: Start with minimal permissions, add as needed
- **Conflict resolution**: DENY always wins, explicit over implicit
- **LLM integration point**: After semantic analysis, before code generation
- **Database pattern**: Dynamic (users/resources) + Static (policies) + Append-only (logs)

---

## 10. Example Use Case

**Scenario**: Alice (Admin, IT) requests read access to DB_Finance at 2 PM

```spl
USER alice { role: Admin, department: IT }
RESOURCE DB_Finance { path: /data/financial, type: database }
ALLOW action: read, write ON RESOURCE: DB_Finance 
IF (user.role == "Admin" AND time.hour >= 9 AND time.hour <= 17)
```

**Evaluation**:
1. Context: `{user.role: "Admin", time.hour: 14}`
2. Condition: `"Admin" == "Admin" AND 14 >= 9 AND 14 <= 17` → `True`
3. Decision: **ALLOWED** (ALLOW policy matched)
4. Logged to audit_logs: `{username: "alice", action: "read", resource: "DB_Finance", allowed: true}`

---

**This simplified guide covers all essential aspects of the SPL system. Use it as a reference when implementing any component.**